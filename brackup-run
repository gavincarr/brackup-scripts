#!/usr/bin/perl
#
# Brackup wrapper script, supporting (optionally) snapshots, monthly backups,
# and pre- and post-run scripts.
#

use strict;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Basename;
use Config::Tiny;
use DateTime;
use LWP::UserAgent;
use HTTP::Request::Common;

sub usage {
  die "usage: " . basename($0) . " [-v] [-n] [-t <target>] [-d <run_dir>] [--monthly] [-u <murl>] [--snapshot] <source> [<source2>...]\n";
}

my $run_dir = '/root/brackup';
my ($help, $noop, $verbose, $snapshot, $monthly, $monthly_url, $target);
usage unless GetOptions(
  'help|h|?'            => \$verbose,
  'noop|n'              => \$noop,
  'verbose|v'           => \$verbose,
  'dir|run-dir|d=s'     => \$run_dir,
  'snapshot|s!'         => \$snapshot,
  'monthly|m!'          => \$monthly,
  'monthly-url|u=s'     => \$monthly_url,
  'target|t=s'          => \$target,
);
usage if $help;
usage unless @ARGV;

$< == 0        or die "Must run as root - aborting";
chdir $run_dir or die "Cannot cd to $run_dir";

# Load config file, if available
my $config_file = -f 'brackup-run.conf' ? 'brackup-run.conf' : '/etc/brackup-run.conf';
my $config = Config::Tiny->read($config_file) if -f $config_file;
if ($config) {
  $monthly          = $config->{_}->{monthly}      if ! defined $monthly;
  $snapshot         = $config->{_}->{snapshot}     if ! defined $snapshot;
  $monthly_url      = $config->{_}->{monthly_url}  if ! defined $monthly_url;
  die "monthly_url is not set, required in monthly mode\n" 
    if $monthly and ! $monthly_url;
  $monthly_url =~ s! /$ !!x if $monthly_url;
}

my ($ua, $month);
if ($monthly) {
  $ua = LWP::UserAgent->new;
  $month = DateTime->today->strftime('%Y%m');
}

if ($verbose) {
  printf STDERR "+ run_dir: %s\n",      $run_dir;
  printf STDERR "+ snapshot: %s\n",     $snapshot || '';
  printf STDERR "+ monthly: %s\n",      $monthly || '';
  printf STDERR "+ monthly_url: %s\n",  $monthly_url || '';
  printf STDERR "+ month: %s\n",        $month || '' if $monthly;
}

# Check for pre_run and post_run scripts
my ($pre_run, $post_run);
if (my $pre_run = $config->{pre_run}) {
  die "Missing pre_run script '$pre_run'\n" unless -f $pre_run;
  die "Non-readable/executable pre_run script '$pre_run'\n" unless -x $pre_run;
}
if (my $post_run = $config->{post_run}) {
  die "Missing post_run script '$post_run'\n" unless -f $post_run;
  die "Non-readable/executable post_run script '$post_run'\n" unless -x $post_run;
}

# Run $pre_run script, if set
if ($pre_run) {
  system($pre_run);
  die "pre_run script '$pre_run' returned non-zero exit code - aborting\n"
    if $? != 0;
}

# Iterate over sources
my $rc = 0;
for my $source (@ARGV) {
  printf STDERR "+ [ starting brackup of source '$source' ]\n" if $verbose;

  $target = $config->{$source}->{target} || $config->{_}->{target} if ! defined $target;
  die "Required parameter 'target' is not set for source '$source'\n" unless $target;
  printf STDERR "+ target: %s\n", $target || '' if $verbose;

  # If monthly mode, check if we this backup should be a monthly
  my $murl = "$monthly_url/month-$source-$target";
  printf STDERR "+ murl: %s\n", $murl if $verbose;
  my $monthly_update = 0;
  my $source_variant = $source;
  if ($monthly) {
    my $resp = $ua->get( $murl );
    printf STDERR "+ murl_content: %s\n", ($resp->decoded_content||0) 
      if $resp->is_success && $verbose;
    if (! $resp->is_success || $month > ($resp->decoded_content||0)) {
      $monthly_update++;
      $source_variant .= '-monthly';
    }
  }

  # Get snapshot parameters and create snapshot
  my $snap;
  if ($snapshot) {
    $snap = Snapshot->new($config, $source, $noop, $verbose);
    $snap->dump if $verbose;

    # Run $snap_cmd (even in $noop mode)
    my $snap_cmd = $snap->cmd;
    print STDERR "+ snap_cmd: $snap_cmd\n" if $verbose;
    system($snap_cmd);
    die "snap cmd '$snap_cmd' failed - aborting\n" unless $? == 0;
  }

  # Run brackup
  my $vflag = $verbose ? '-v' : '';
  my $cmd = "/usr/bin/brackup --from=$source_variant --to=$target --save-stats $vflag";
  print STDERR "+ cmd: $cmd\n" if $verbose;
  unless ($noop) {
    system($cmd);
    $rc = $?;

    # Update monthly state file if all okay
    if ($rc == 0 && $monthly_update) {
      $ua->request( PUT($murl, Content => "$month\n") )
        or die "PUT to $murl failed: $!";
    }
  }
  
  # Unsnap regardless of success for failure
  if ($snapshot) {
    my $unsnap_cmd = $snap->cmd_unsnap;
    print STDERR "+ unsnap_cmd: $unsnap_cmd\n" if $verbose;
    system($unsnap_cmd);
    warn "Warning: unsnap cmd '$unsnap_cmd' failed\n" unless $? == 0;
  }

  last if $rc;
}

# Warn $post_run script, if set
if ($post_run) {
  system("$post_run $rc");
  die "post_run script '$post_run' returned non-zero exit code - aborting\n"
    if $? != 0;
}

exit $rc if $rc;
exit 0;


# Snapshot class to isolate snapshot parameter logic
package Snapshot;

use File::Basename;

sub new {
  my ($class, $config, $source, $noop, $verbose) = @_;
  my $self = bless {}, $class;

  $self->{snap} = dirname($0) . '/snap';
  -x $self->{snap} or die "Cannot find 'snap' executable: $self->{snap}\n";
  $self->{unsnap} = dirname($0) . '/unsnap';
  -x $self->{unsnap} or die "Cannot find 'unsnap' executable: $self->{unsnap}\n";

  $self->{mountpoint} = $config->{$source}->{mountpoint} || "/$source";

  $self->{size} = $config->{$source}->{snapshot_size} || $config->{_}->{snapshot_size};
  $self->{size} = $self->{size} ? '-S ' . $self->{size} : '';
  $self->{noop} = $noop ? '-n ' : '';
  $self->{verbose} = $verbose ? '-v ' : '';

  return $self;
}

sub dump {
  my $self = shift;

  printf STDERR "+ snap: $self->{snap}\n";
  printf STDERR "+ unsnap: $self->{unsnap}\n";
  printf STDERR "+ mountpoint: $self->{mountpoint}\n";
  printf STDERR "+ size: $self->{size}\n";
}

sub cmd {
  my $self = shift;
  sprintf "%s %s%s%s%s", 
    $self->{snap}, $self->{verbose}, $self->{noop}, $self->{size}, $self->{mountpoint};
}

sub cmd_unsnap {
  my $self = shift;
  sprintf "%s %s%s%s%s", 
    $self->{unsnap}, $self->{verbose}, $self->{noop}, $self->{mountpoint};
}

1;

__END__

